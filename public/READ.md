2019-04-22
如何开发一套简易框架。
研究别人的框架，终究不如自己想办法开发一套框架出来。能够更深入的理解PHP,也能借此提升技术综合能力。


1.环境判断
IIS环境、apache、Nginx三种环境对于请求参数的一些变量是不同的
因此，如果框架想要兼容不同的服务器环境，对相应的条件是需要判断的
这里仅记录，但是不做兼容


env
1.服务器apache|nginx

2.php >= 7.2.*













1.PHP自动创建类的实例方式？
答：反射方式,判断默认构造函数是否存在，判断是否有自定义的初始化方法，如果存在，优先使用自定义初始化方法来创建对象，如果需要传递初始化数据
也可以基于不同方式来传递给构造函数，如果没有自定义构造函数，那么使用默认构造函数来实例化对象，通用如果默认构造函数有被重载，也需要按照
判断来决定是否传递相关参数






2.使用容器的方式，创建类的实例，有什么好处？
答：依赖注入、控制反转、容器、工厂模式








类的自动加载：
按照定义的规则，来拼接类文件存在的相对路径或者是决定路径，判断文件是否存在，如果存在使用include_once、require_once来引入文件，否则可以抛出异常如classNotFoundException or FileNotExistException


首先需要include 或者 require 引入对应的文件。 而文件的名称需要遵循一定的规则，比如PSR-4,否者，完全没办法知道需要记载的类在哪个文件中，如何去引入。


为了保证类文件的自动加载或者说引入include_once   require_once

同样聊到了include 以及 require 的区别，突然有点忘记了，

类的自动加载机制是当调用了一个没有显示引入的类时，PHP会执行一个补偿机制，查询是否有定义自动加载函数，如果没有，那么会执行默认的自动加载函数，如果依旧找不到相关类文件
那么就会报错




什么是面向对象？


面向对象的概念 特点是类的继承  方法的重载



通过执行框架应用类的run()-send()链式方式来完成数据的输出，
那么run()函数最后返回的就不一定是应用实例，也可以是一个response的实例
通过调用response实例的send()方法来完成数据的发送和返回
如果在run()中执行出现异常，那么需要捕获并处理，如果是正常执行，也需要声明一个对象实例，区别只是输出内容的不同而已

如果抛出的是异常，使用异常来初始化response实例


框架的Request类是对一次请求中超全局变量的封装以及解析
超全局变量包括
$_SERVER
$_GET     --get请求方式传递的数据
$_POST    --post方式传递的变量
$_FILES   -- 文件上传
$_COOKIE  --  
$_SESSION -- 
$_REQUEST -- 
$_ENV     -- 


没有其他想法Request基本包含了全部的全局变量的数据和方法，
1.属性  
  当被实例时，需要适用所有全局变量来赋值初始化
  按照实际使用需要来一点一点的增加相关属性和方法吧，一口气预设好所有的东西不合适，毕竟在实际的框架使用中很多方法和属性其实也是基本不会被用到的



2.方法








那么暂时抛开实际的业务逻辑，先满足的关键类就是Request Response两个类
前者完成对url请求的解析与封装
后者完成对于返回结果的处理，可以预见针对每一个结果可能的返回结果为1.视图 2.数据 3.异常、4错误信息
为了增加代码的健壮性，所有的代码都需要放置到try_catch() 块中来保留，也就是说response的实例 需要实现__toString 魔术方法


怎么发送数据呢 echo ？ 


怎么定位整个框架的根目录  以及应用类库的目录   如果在index中



到这里，基本实现了类的自动加载以及使用容器创建一个类的实例。

接下来，困难的来了。如何根据URL来解析运行相关的代码。比如，/module_name/controller/action 
包含了路径的解析。以及控制器的实例化，action的方法调用。

应用目录的指定



http://domain:port/module/controller/action(.suffix)
.htaccess 文件对美化之后的url进行补全








模型中声明data属性 为数组来保存对应的数据表对应记录的数据
字段名为key值，字段值为 value 值 

不对，类显示声明的私有属性，都不允许通过__get 魔术方法来访问而是通过自定义的getAttr方法来获取相应的值，
如果传递的key参数不存在data中，那么返回错误或者抛出异常






        
使用composer 安装的第三方类库 还有无法自动引入类的问题存在而这个问题只有同步更新相关composer autoloader.php文件才能解决





一个框架中，肯定需要包含对数据库的操作的封装。pdo方式的操作与连接是当前php主流的一种数据库操作方式






如何使用composer 管理框架以及 自动识别composer 管理的第三方类库


/**
 * php>5.6的composer加载类库的方法
 * 1.使用composer管理类，比如安装一个类之后，就会在/vendor/composer/文件里面的几个文件中，自动生成类库的相关配置
 * autoload_static.php中会自动生成一些变量值，就是相应类库的类信息文件之类；
 * autoload_files.php是加载一些助手函数的文件类；
 * autoload_real.php是实现加载的功能类；
 * ClassLoader.php实现类加载的助手类
 * 其他相关类也可以看一下，这里只是分析php>5.6会用到的文件。
 * autoload_static.php其实已经包含了autoload_classmap.php、autoload_namespaces.php、autoload_psr4.php这些文件的值。
 * 2.使用composer管理的项目，在入口文件index.php中会包含autoload.php文件，而这个文件会去调用autoload_real.php文件类的getLoader()方法去实现类加载
 * 3.getLoader方法的实现原理，其实就是使用php的spl_autoload_register()方法注册自动加载器。只要注册了相应方法到加载器中。这个方法可以在执行程序时，当需要调用其他类的时候通过这个函数去自动加载目标类
 * 4.而第三步具体怎么找到相应类文件，这个可以去具体方法中查看。大致是使用了autoload_static.php,autoload_files.php文件中的数据，然后在ClassLoader.php中实现相应逻辑判断，并返回包含相应类文件。




 依赖注入：不是在类的使用方法中实例化需要使用的类，而是传递一个对象的实例对象
        
